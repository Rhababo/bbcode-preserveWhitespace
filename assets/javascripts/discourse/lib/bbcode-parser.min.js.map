{"version":3,"file":"bbcode-parser.min.js","sources":["../../../../node_modules/@bbob/preset/es/index.js","../../../../bbcode-src/tags/bold.js","../../../../bbcode-src/preset.js","../../../../bbcode-src/tags/font.js","../../../../bbcode-src/tags/nobr.js","../../../../node_modules/@bbob/plugin-helper/es/char.js","../../../../node_modules/@bbob/plugin-helper/es/helpers.js","../../../../node_modules/@bbob/plugin-helper/es/TagNode.js","../../../../node_modules/@bbob/parser/es/Token.js","../../../../node_modules/@bbob/parser/es/utils.js","../../../../node_modules/@bbob/parser/es/lexer.js","../../../../node_modules/@bbob/parser/es/parse.js","../../../../node_modules/@bbob/core/es/utils.js","../../../../node_modules/@bbob/core/es/index.js","../../../../node_modules/@bbob/html/es/index.js","../../../../bbcode-src/plugins/lineBreak.js","../../../../bbcode-src/index.js"],"sourcesContent":["/* eslint-disable indent */ const isTagNode = (el)=>typeof el === 'object' && !!el.tag;\nfunction process(tags, tree, core, options) {\n    tree.walk((node)=>isTagNode(node) && tags[node.tag] ? tags[node.tag](node, core, options) : node);\n}\n/**\n * Creates preset for @bbob/core\n * @param defTags {Object}\n * @param processor {Function} a processor function of tree\n * @returns {function(*=): function(*=, *=): void}\n */ function createPreset(defTags, processor = process) {\n    const presetFactory = (opts = {})=>{\n        presetFactory.options = Object.assign(presetFactory.options || {}, opts);\n        const presetExecutor = (tree, core)=>processor(defTags, tree, core, presetFactory.options);\n        presetExecutor.options = presetFactory.options;\n        return presetExecutor;\n    };\n    presetFactory.extend = (callback)=>createPreset(callback(defTags, presetFactory.options), processor);\n    return presetFactory;\n}\nexport { createPreset };\nexport default createPreset;\n","export const bold = (node) => {\n  // console.log(node);\n  return {\n    tag: \"span\",\n    attr: { style: \"font-weight: bold\", 'data-rpn-bbcode': '' },\n    content: node.content,\n  };\n};\n","import { createPreset } from \"@bbob/preset\";\nimport { bold } from \"./tags/bold\";\nimport { font } from \"./tags/font\";\nimport { nobr } from \"./tags/nobr\";\n\nconst tags = {\n  b: bold,\n  font,\n  nobr,\n};\n\nconst availableTags = Object.keys(tags);\n\nconst preset = createPreset(tags);\n\nexport { availableTags, tags, preset };\nexport default preset;\n","// import { getUniqAttr } from \"@bbob/plugin-helper\";\n\nexport const font = (node, options) => {\n  // console.log(node);\n  // console.log(node.attrs);\n  // console.log(getUniqAttr(node.attrs));\n  // options.data = [...options.data, 1];\n  // eslint-disable-next-line no-console\n  console.log(options);\n  return {\n    tag: \"span\",\n    content: node.content,\n  };\n};\n","/**\n * Disables line breaks for given content\n * @example\n * ```\n * [nobr]test\n * test\n * test\n * [/nobr]\n *\n * test test test\n * ```\n */\nexport const nobr = (node) => {\n  return { disableLineBreakConversion: true, content: node.content };\n};\n","const N = '\\n';\nconst TAB = '\\t';\nconst F = '\\f';\nconst R = '\\r';\nconst EQ = '=';\nconst QUOTEMARK = '\"';\nconst SPACE = ' ';\nconst OPEN_BRAKET = '[';\nconst CLOSE_BRAKET = ']';\nconst SLASH = '/';\nconst BACKSLASH = '\\\\';\nexport { N, F, R, EQ, TAB, SPACE, SLASH, BACKSLASH, QUOTEMARK, OPEN_BRAKET, CLOSE_BRAKET };\n","import { N } from './char';\nconst isTagNode = (el)=>typeof el === 'object' && !!el.tag;\nconst isStringNode = (el)=>typeof el === 'string';\nconst isEOL = (el)=>el === N;\nconst keysReduce = (obj, reduce, def)=>Object.keys(obj).reduce(reduce, def);\nconst getNodeLength = (node)=>{\n    if (isTagNode(node)) {\n        return node.content.reduce((count, contentNode)=>count + getNodeLength(contentNode), 0);\n    }\n    if (isStringNode(node)) {\n        return node.length;\n    }\n    return 0;\n};\n/**\n * Appends value to Tag Node\n * @param {TagNode} node\n * @param value\n */ const appendToNode = (node, value)=>{\n    node.content.push(value);\n};\n/**\n * Replaces \" to &qquot;\n * @param {String} value\n */ const escapeHTML = (value)=>value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url\n    .replace(/(javascript|data|vbscript):/gi, '$1%3A');\n/**\n * Acept name and value and return valid html5 attribute string\n * @param {String} name\n * @param {String} value\n * @return {string}\n */ const attrValue = (name, value)=>{\n    const type = typeof value;\n    const types = {\n        boolean: ()=>value ? `${name}` : '',\n        number: ()=>`${name}=\"${value}\"`,\n        string: ()=>`${name}=\"${escapeHTML(value)}\"`,\n        object: ()=>`${name}=\"${escapeHTML(JSON.stringify(value))}\"`\n    };\n    return types[type] ? types[type]() : '';\n};\n/**\n * Transforms attrs to html params string\n * @param values\n */ const attrsToString = (values)=>{\n    // To avoid some malformed attributes\n    if (values == null) {\n        return '';\n    }\n    return keysReduce(values, (arr, key)=>[\n            ...arr,\n            attrValue(key, values[key])\n        ], [\n        ''\n    ]).join(' ');\n};\n/**\n * Gets value from\n * @example\n * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'\n * @param attrs\n * @returns {string}\n */ const getUniqAttr = (attrs)=>keysReduce(attrs, (res, key)=>attrs[key] === key ? attrs[key] : null, null);\nexport { attrsToString, attrValue, appendToNode, escapeHTML, getNodeLength, getUniqAttr, isTagNode, isStringNode, isEOL };\n","import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from './char';\nimport { getNodeLength, appendToNode, attrsToString, attrValue, getUniqAttr } from './helpers';\nconst getTagAttrs = (tag, params)=>{\n    const uniqAattr = getUniqAttr(params);\n    if (uniqAattr) {\n        const tagAttr = attrValue(tag, uniqAattr);\n        const attrs = {\n            ...params\n        };\n        delete attrs[uniqAattr];\n        const attrsStr = attrsToString(attrs);\n        return `${tagAttr}${attrsStr}`;\n    }\n    return `${tag}${attrsToString(params)}`;\n};\nclass TagNode {\n    attr(name, value) {\n        if (typeof value !== 'undefined') {\n            this.attrs[name] = value;\n        }\n        return this.attrs[name];\n    }\n    append(value) {\n        return appendToNode(this, value);\n    }\n    get length() {\n        return getNodeLength(this);\n    }\n    toTagStart({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n        const tagAttrs = getTagAttrs(this.tag, this.attrs);\n        return `${openTag}${tagAttrs}${closeTag}`;\n    }\n    toTagEnd({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n        return `${openTag}${SLASH}${this.tag}${closeTag}`;\n    }\n    toTagNode() {\n        return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);\n    }\n    toString({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n        const isEmpty = this.content.length === 0;\n        const content = this.content.reduce((r, node)=>r + node.toString({\n                openTag,\n                closeTag\n            }), '');\n        const tagStart = this.toTagStart({\n            openTag,\n            closeTag\n        });\n        if (isEmpty) {\n            return tagStart;\n        }\n        return `${tagStart}${content}${this.toTagEnd({\n            openTag,\n            closeTag\n        })}`;\n    }\n    constructor(tag, attrs, content){\n        this.tag = tag;\n        this.attrs = attrs;\n        this.content = Array.isArray(content) ? content : [\n            content\n        ];\n    }\n}\nTagNode.create = (tag, attrs = {}, content = [])=>new TagNode(tag, attrs, content);\nTagNode.isOf = (node, type)=>node.tag === type;\nexport { TagNode };\nexport default TagNode;\n","import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from '@bbob/plugin-helper';\n// type, value, line, row,\nconst TOKEN_TYPE_ID = 'type'; // 0;\nconst TOKEN_VALUE_ID = 'value'; // 1;\nconst TOKEN_COLUMN_ID = 'row'; // 2;\nconst TOKEN_LINE_ID = 'line'; // 3;\nconst TOKEN_TYPE_WORD = 1; // 'word';\nconst TOKEN_TYPE_TAG = 2; // 'tag';\nconst TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\nconst TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\nconst TOKEN_TYPE_SPACE = 5; // 'space';\nconst TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\n/**\n * @param {Token} token\n * @returns {string}\n */ const getTokenValue = (token)=>{\n    if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\n        return token[TOKEN_VALUE_ID];\n    }\n    return '';\n};\n/**\n * @param {Token}token\n * @returns {number}\n */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\nconst getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isTextToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\n    }\n    return false;\n};\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isTagToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\n    }\n    return false;\n};\nconst isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);\nconst isTagStart = (token)=>!isTagEnd(token);\nconst isAttrNameToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\n    }\n    return false;\n};\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isAttrValueToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\n    }\n    return false;\n};\nconst getTagName = (token)=>{\n    const value = getTokenValue(token);\n    return isTagEnd(token) ? value.slice(1) : value;\n};\nconst convertTagToText = (token)=>{\n    let text = OPEN_BRAKET;\n    text += getTokenValue(token);\n    text += CLOSE_BRAKET;\n    return text;\n};\nclass Token {\n    isEmpty() {\n        // eslint-disable-next-line no-restricted-globals\n        return isNaN(this[TOKEN_TYPE_ID]);\n    }\n    isText() {\n        return isTextToken(this);\n    }\n    isTag() {\n        return isTagToken(this);\n    }\n    isAttrName() {\n        return isAttrNameToken(this);\n    }\n    isAttrValue() {\n        return isAttrValueToken(this);\n    }\n    isStart() {\n        return isTagStart(this);\n    }\n    isEnd() {\n        return isTagEnd(this);\n    }\n    getName() {\n        return getTagName(this);\n    }\n    getValue() {\n        return getTokenValue(this);\n    }\n    getLine() {\n        return getTokenLine(this);\n    }\n    getColumn() {\n        return getTokenColumn(this);\n    }\n    toString() {\n        return convertTagToText(this);\n    }\n    /**\n   * @param {String} type\n   * @param {String} value\n   * @param line\n   * @param row\n   */ constructor(type, value, line, row){\n        this[TOKEN_TYPE_ID] = Number(type);\n        this[TOKEN_VALUE_ID] = String(value);\n        this[TOKEN_LINE_ID] = Number(line);\n        this[TOKEN_COLUMN_ID] = Number(row);\n    }\n}\nexport const TYPE_ID = TOKEN_TYPE_ID;\nexport const VALUE_ID = TOKEN_VALUE_ID;\nexport const LINE_ID = TOKEN_LINE_ID;\nexport const COLUMN_ID = TOKEN_COLUMN_ID;\nexport const TYPE_WORD = TOKEN_TYPE_WORD;\nexport const TYPE_TAG = TOKEN_TYPE_TAG;\nexport const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\nexport const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\nexport const TYPE_SPACE = TOKEN_TYPE_SPACE;\nexport const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\nexport { Token };\nexport default Token;\n","import { QUOTEMARK, BACKSLASH } from '@bbob/plugin-helper';\nfunction CharGrabber(source, options) {\n    const cursor = {\n        pos: 0,\n        len: source.length\n    };\n    const substrUntilChar = (char)=>{\n        const { pos  } = cursor;\n        const idx = source.indexOf(char, pos);\n        return idx >= 0 ? source.substring(pos, idx) : '';\n    };\n    const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;\n    const hasNext = ()=>cursor.len > cursor.pos;\n    const isLast = ()=>cursor.pos === cursor.len;\n    const skip = (num = 1, silent)=>{\n        cursor.pos += num;\n        if (options && options.onSkip && !silent) {\n            options.onSkip();\n        }\n    };\n    const rest = ()=>source.substring(cursor.pos);\n    const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);\n    const curr = ()=>source[cursor.pos];\n    const prev = ()=>{\n        const prevPos = cursor.pos - 1;\n        return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;\n    };\n    const next = ()=>{\n        const nextPos = cursor.pos + 1;\n        return nextPos <= source.length - 1 ? source[nextPos] : null;\n    };\n    const grabWhile = (cond, silent)=>{\n        let start = 0;\n        if (hasNext()) {\n            start = cursor.pos;\n            while(hasNext() && cond(curr())){\n                skip(1, silent);\n            }\n        }\n        return source.substring(start, cursor.pos);\n    };\n    /**\n   * @type {skip}\n   */ this.skip = skip;\n    /**\n   * @returns {Boolean}\n   */ this.hasNext = hasNext;\n    /**\n   * @returns {String}\n   */ this.getCurr = curr;\n    /**\n   * @returns {String}\n   */ this.getRest = rest;\n    /**\n   * @returns {String}\n   */ this.getNext = next;\n    /**\n   * @returns {String}\n   */ this.getPrev = prev;\n    /**\n   * @returns {Boolean}\n   */ this.isLast = isLast;\n    /**\n   * @returns {Boolean}\n   */ this.includes = includes;\n    /**\n   * @param {Function} cond\n   * @param {Boolean} silent\n   * @return {String}\n   */ this.grabWhile = grabWhile;\n    /**\n   * @param {Number} num\n   * @return {String}\n   */ this.grabN = grabN;\n    /**\n   * Grabs rest of string until it find a char\n   * @param {String} char\n   * @return {String}\n   */ this.substrUntilChar = substrUntilChar;\n}\n/**\n * Creates a grabber wrapper for source string, that helps to iterate over string char by char\n * @param {String} source\n * @param {Object} options\n * @param {Function} options.onSkip\n * @return CharGrabber\n */ export const createCharGrabber = (source, options)=>new CharGrabber(source, options);\n/**\n * Trims string from start and end by char\n * @example\n *  trimChar('*hello*', '*') ==> 'hello'\n * @param {String} str\n * @param {String} charToRemove\n * @returns {String}\n */ export const trimChar = (str, charToRemove)=>{\n    while(str.charAt(0) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(1);\n    }\n    while(str.charAt(str.length - 1) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(0, str.length - 1);\n    }\n    return str;\n};\n/**\n * Unquotes \\\" to \"\n * @param str\n * @return {String}\n */ export const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);\nfunction NodeList(values = []) {\n    const nodes = values;\n    const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;\n    const flushLast = ()=>nodes.length ? nodes.pop() : false;\n    const push = (value)=>nodes.push(value);\n    const toArray = ()=>nodes;\n    this.push = push;\n    this.toArray = toArray;\n    this.getLast = getLast;\n    this.flushLast = flushLast;\n}\n/**\n *\n * @param values\n * @return {NodeList}\n */ export const createList = (values = [])=>new NodeList(values);\n","/* eslint-disable no-plusplus,no-param-reassign */ import { OPEN_BRAKET, CLOSE_BRAKET, QUOTEMARK, BACKSLASH, SLASH, SPACE, TAB, EQ, N } from '@bbob/plugin-helper';\nimport { Token, TYPE_ATTR_NAME, TYPE_ATTR_VALUE, TYPE_NEW_LINE, TYPE_SPACE, TYPE_TAG, TYPE_WORD } from './Token';\nimport { createCharGrabber, trimChar, unquote } from './utils';\n// for cases <!-- -->\nconst EM = '!';\n/**\n * Creates a Token entity class\n * @param {Number} type\n * @param {String} value\n * @param {Number} r line number\n * @param {Number} cl char number in line\n */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);\n/**\n * @typedef {Object} Lexer\n * @property {Function} tokenize\n * @property {Function} isTokenNested\n */ /**\n * @param {String} buffer\n * @param {Object} options\n * @param {Function} options.onToken\n * @param {String} options.openTag\n * @param {String} options.closeTag\n * @param {Boolean} options.enableEscapeTags\n * @return {Lexer}\n */ function createLexer(buffer, options = {}) {\n    const STATE_WORD = 0;\n    const STATE_TAG = 1;\n    const STATE_TAG_ATTRS = 2;\n    const TAG_STATE_NAME = 0;\n    const TAG_STATE_ATTR = 1;\n    const TAG_STATE_VALUE = 2;\n    let row = 0;\n    let col = 0;\n    let tokenIndex = -1;\n    let stateMode = STATE_WORD;\n    let tagMode = TAG_STATE_NAME;\n    let contextFreeTag = '';\n    const tokens = new Array(Math.floor(buffer.length));\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    const escapeTags = !!options.enableEscapeTags;\n    const contextFreeTags = options.contextFreeTags || [];\n    const onToken = options.onToken || (()=>{});\n    const RESERVED_CHARS = [\n        closeTag,\n        openTag,\n        QUOTEMARK,\n        BACKSLASH,\n        SPACE,\n        TAB,\n        EQ,\n        N,\n        EM\n    ];\n    const NOT_CHAR_TOKENS = [\n        openTag,\n        SPACE,\n        TAB,\n        N\n    ];\n    const WHITESPACES = [\n        SPACE,\n        TAB\n    ];\n    const SPECIAL_CHARS = [\n        EQ,\n        SPACE,\n        TAB\n    ];\n    const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\n    const isNewLine = (char)=>char === N;\n    const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\n    const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\n    const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\n    const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;\n    const isEscapeChar = (char)=>char === BACKSLASH;\n    const onSkip = ()=>{\n        col++;\n    };\n    const unq = (val)=>unquote(trimChar(val, QUOTEMARK));\n    const checkContextFreeMode = (name, isClosingTag)=>{\n        if (contextFreeTag !== '' && isClosingTag) {\n            contextFreeTag = '';\n        }\n        if (contextFreeTag === '' && contextFreeTags.includes(name)) {\n            contextFreeTag = name;\n        }\n    };\n    const chars = createCharGrabber(buffer, {\n        onSkip\n    });\n    /**\n   * Emits newly created token to subscriber\n   * @param {Number} type\n   * @param {String} value\n   */ function emitToken(type, value) {\n        const token = createToken(type, value, row, col);\n        onToken(token);\n        tokenIndex += 1;\n        tokens[tokenIndex] = token;\n    }\n    function nextTagState(tagChars, isSingleValueTag) {\n        if (tagMode === TAG_STATE_ATTR) {\n            const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));\n            const name = tagChars.grabWhile(validAttrName);\n            const isEnd = tagChars.isLast();\n            const isValue = tagChars.getCurr() !== EQ;\n            tagChars.skip();\n            if (isEnd || isValue) {\n                emitToken(TYPE_ATTR_VALUE, unq(name));\n            } else {\n                emitToken(TYPE_ATTR_NAME, name);\n            }\n            if (isEnd) {\n                return TAG_STATE_NAME;\n            }\n            if (isValue) {\n                return TAG_STATE_ATTR;\n            }\n            return TAG_STATE_VALUE;\n        }\n        if (tagMode === TAG_STATE_VALUE) {\n            let stateSpecial = false;\n            const validAttrValue = (char)=>{\n                // const isEQ = char === EQ;\n                const isQM = char === QUOTEMARK;\n                const prevChar = tagChars.getPrev();\n                const nextChar = tagChars.getNext();\n                const isPrevSLASH = prevChar === BACKSLASH;\n                const isNextEQ = nextChar === EQ;\n                const isWS = isWhiteSpace(char);\n                // const isPrevWS = isWhiteSpace(prevChar);\n                const isNextWS = isWhiteSpace(nextChar);\n                if (stateSpecial && isSpecialChar(char)) {\n                    return true;\n                }\n                if (isQM && !isPrevSLASH) {\n                    stateSpecial = !stateSpecial;\n                    if (!stateSpecial && !(isNextEQ || isNextWS)) {\n                        return false;\n                    }\n                }\n                if (!isSingleValueTag) {\n                    return isWS === false;\n                // return (isEQ || isWS) === false;\n                }\n                return true;\n            };\n            const name1 = tagChars.grabWhile(validAttrValue);\n            tagChars.skip();\n            emitToken(TYPE_ATTR_VALUE, unq(name1));\n            if (tagChars.isLast()) {\n                return TAG_STATE_NAME;\n            }\n            return TAG_STATE_ATTR;\n        }\n        const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());\n        const name2 = tagChars.grabWhile(validName);\n        emitToken(TYPE_TAG, name2);\n        checkContextFreeMode(name2);\n        tagChars.skip();\n        // in cases when we has [url=someval]GET[/url] and we dont need to parse all\n        if (isSingleValueTag) {\n            return TAG_STATE_VALUE;\n        }\n        const hasEQ = tagChars.includes(EQ);\n        return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\n    }\n    function stateTag() {\n        const currChar = chars.getCurr();\n        const nextChar = chars.getNext();\n        chars.skip();\n        // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\n        const substr = chars.substrUntilChar(closeTag);\n        const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\n        if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\n            emitToken(TYPE_WORD, currChar);\n            return STATE_WORD;\n        }\n        // [myTag   ]\n        const isNoAttrsInTag = substr.indexOf(EQ) === -1;\n        // [/myTag]\n        const isClosingTag = substr[0] === SLASH;\n        if (isNoAttrsInTag || isClosingTag) {\n            const name = chars.grabWhile((char)=>char !== closeTag);\n            chars.skip(); // skip closeTag\n            emitToken(TYPE_TAG, name);\n            checkContextFreeMode(name, isClosingTag);\n            return STATE_WORD;\n        }\n        return STATE_TAG_ATTRS;\n    }\n    function stateAttrs() {\n        const silent = true;\n        const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\n        const tagGrabber = createCharGrabber(tagStr, {\n            onSkip\n        });\n        const hasSpace = tagGrabber.includes(SPACE);\n        tagMode = TAG_STATE_NAME;\n        while(tagGrabber.hasNext()){\n            tagMode = nextTagState(tagGrabber, !hasSpace);\n        }\n        chars.skip(); // skip closeTag\n        return STATE_WORD;\n    }\n    function stateWord() {\n        if (isNewLine(chars.getCurr())) {\n            emitToken(TYPE_NEW_LINE, chars.getCurr());\n            chars.skip();\n            col = 0;\n            row++;\n            return STATE_WORD;\n        }\n        if (isWhiteSpace(chars.getCurr())) {\n            const word = chars.grabWhile(isWhiteSpace);\n            emitToken(TYPE_SPACE, word);\n            return STATE_WORD;\n        }\n        if (chars.getCurr() === openTag) {\n            if (contextFreeTag) {\n                const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;\n                const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;\n                const foundTag = chars.grabN(fullTagLen);\n                const isEndContextFreeMode = foundTag === fullTagName;\n                if (isEndContextFreeMode) {\n                    return STATE_TAG;\n                }\n            } else if (chars.includes(closeTag)) {\n                return STATE_TAG;\n            }\n            emitToken(TYPE_WORD, chars.getCurr());\n            chars.skip();\n            return STATE_WORD;\n        }\n        if (escapeTags) {\n            if (isEscapeChar(chars.getCurr())) {\n                const currChar = chars.getCurr();\n                const nextChar = chars.getNext();\n                chars.skip(); // skip the \\ without emitting anything\n                if (isEscapableChar(nextChar)) {\n                    chars.skip(); // skip past the [, ] or \\ as well\n                    emitToken(TYPE_WORD, nextChar);\n                    return STATE_WORD;\n                }\n                emitToken(TYPE_WORD, currChar);\n                return STATE_WORD;\n            }\n            const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\n            const word1 = chars.grabWhile(isChar);\n            emitToken(TYPE_WORD, word1);\n            return STATE_WORD;\n        }\n        const word2 = chars.grabWhile(isCharToken);\n        emitToken(TYPE_WORD, word2);\n        return STATE_WORD;\n    }\n    function tokenize() {\n        stateMode = STATE_WORD;\n        while(chars.hasNext()){\n            switch(stateMode){\n                case STATE_TAG:\n                    stateMode = stateTag();\n                    break;\n                case STATE_TAG_ATTRS:\n                    stateMode = stateAttrs();\n                    break;\n                case STATE_WORD:\n                default:\n                    stateMode = stateWord();\n                    break;\n            }\n        }\n        tokens.length = tokenIndex + 1;\n        return tokens;\n    }\n    function isTokenNested(token) {\n        const value = openTag + SLASH + token.getValue();\n        // potential bottleneck\n        return buffer.indexOf(value) > -1;\n    }\n    return {\n        tokenize,\n        isTokenNested\n    };\n}\nexport const createTokenOfType = createToken;\nexport { createLexer };\n","import { TagNode, CLOSE_BRAKET, OPEN_BRAKET, isTagNode } from '@bbob/plugin-helper';\nimport { createLexer } from './lexer';\nimport { createList } from './utils';\n/**\n * @public\n * @param {String} input\n * @param {Object} opts\n * @param {Function} opts.createTokenizer\n * @param {Array<string>} opts.onlyAllowTags\n * @param {Array<string>} opts.contextFreeTags\n * @param {Boolean} opts.enableEscapeTags\n * @param {String} opts.openTag\n * @param {String} opts.closeTag\n * @return {Array}\n */ const parse = (input, opts = {})=>{\n    const options = opts;\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    let tokenizer = null;\n    /**\n   * Result AST of nodes\n   * @private\n   * @type {NodeList}\n   */ const nodes = createList();\n    /**\n   * Temp buffer of nodes that's nested to another node\n   * @private\n   * @type {NodeList}\n   */ const nestedNodes = createList();\n    /**\n   * Temp buffer of nodes [tag..]...[/tag]\n   * @private\n   * @type {NodeList}\n   */ const tagNodes = createList();\n    /**\n   * Temp buffer of tag attributes\n   * @private\n   * @type {NodeList}\n   */ const tagNodesAttrName = createList();\n    /**\n   * Cache for nested tags checks\n   */ const nestedTagsMap = new Set();\n    /**\n   *\n   * @param token\n   * @returns {boolean}\n   */ const isTokenNested = (token)=>{\n        const value = token.getValue();\n        if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {\n            nestedTagsMap.add(value);\n            return true;\n        }\n        return nestedTagsMap.has(value);\n    };\n    /**\n   * @param tagName\n   * @returns {boolean}\n   */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));\n    /**\n   * @private\n   * @param {String} value\n   * @return {boolean}\n   */ const isAllowedTag = (value)=>{\n        if (options.onlyAllowTags && options.onlyAllowTags.length) {\n            return options.onlyAllowTags.indexOf(value) >= 0;\n        }\n        return true;\n    };\n    /**\n   * Flushes temp tag nodes and its attributes buffers\n   * @private\n   * @return {Array}\n   */ const flushTagNodes = ()=>{\n        if (tagNodes.flushLast()) {\n            tagNodesAttrName.flushLast();\n        }\n    };\n    /**\n   * @private\n   * @return {Array}\n   */ const getNodes = ()=>{\n        const lastNestedNode = nestedNodes.getLast();\n        if (lastNestedNode && Array.isArray(lastNestedNode.content)) {\n            return lastNestedNode.content;\n        }\n        return nodes.toArray();\n    };\n    /**\n   * @private\n   * @param {string|TagNode} node\n   */ const appendNodes = (node)=>{\n        const items = getNodes();\n        if (Array.isArray(items)) {\n            if (isTagNode(node)) {\n                if (isAllowedTag(node.tag)) {\n                    items.push(node.toTagNode());\n                } else {\n                    items.push(node.toTagStart({\n                        openTag,\n                        closeTag\n                    }));\n                    if (node.content.length) {\n                        node.content.forEach((item)=>{\n                            items.push(item);\n                        });\n                        items.push(node.toTagEnd({\n                            openTag,\n                            closeTag\n                        }));\n                    }\n                }\n            } else {\n                items.push(node);\n            }\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTagStart = (token)=>{\n        flushTagNodes();\n        const tagNode = TagNode.create(token.getValue());\n        const isNested = isTokenNested(token);\n        tagNodes.push(tagNode);\n        if (isNested) {\n            nestedNodes.push(tagNode);\n        } else {\n            appendNodes(tagNode, token);\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTagEnd = (token)=>{\n        flushTagNodes();\n        const lastNestedNode = nestedNodes.flushLast();\n        if (lastNestedNode) {\n            appendNodes(lastNestedNode, token);\n        } else if (typeof options.onError === 'function') {\n            const tag = token.getValue();\n            const line = token.getLine();\n            const column = token.getColumn();\n            options.onError({\n                message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,\n                tagName: tag,\n                lineNumber: line,\n                columnNumber: column\n            });\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTag = (token)=>{\n        // [tag]\n        if (token.isStart()) {\n            handleTagStart(token);\n        }\n        // [/tag]\n        if (token.isEnd()) {\n            handleTagEnd(token);\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleNode = (token)=>{\n        /**\n     * @type {TagNode}\n     */ const lastTagNode = tagNodes.getLast();\n        const tokenValue = token.getValue();\n        const isNested = isTagNested(token);\n        if (lastTagNode) {\n            if (token.isAttrName()) {\n                tagNodesAttrName.push(tokenValue);\n                lastTagNode.attr(tagNodesAttrName.getLast(), '');\n            } else if (token.isAttrValue()) {\n                const attrName = tagNodesAttrName.getLast();\n                if (attrName) {\n                    lastTagNode.attr(attrName, tokenValue);\n                    tagNodesAttrName.flushLast();\n                } else {\n                    lastTagNode.attr(tokenValue, tokenValue);\n                }\n            } else if (token.isText()) {\n                if (isNested) {\n                    lastTagNode.append(tokenValue);\n                } else {\n                    appendNodes(tokenValue);\n                }\n            } else if (token.isTag()) {\n                // if tag is not allowed, just past it as is\n                appendNodes(token.toString());\n            }\n        } else if (token.isText()) {\n            appendNodes(tokenValue);\n        } else if (token.isTag()) {\n            // if tag is not allowed, just past it as is\n            appendNodes(token.toString());\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const onToken = (token)=>{\n        if (token.isTag()) {\n            handleTag(token);\n        } else {\n            handleNode(token);\n        }\n    };\n    tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {\n        onToken,\n        openTag,\n        closeTag,\n        onlyAllowTags: options.onlyAllowTags,\n        contextFreeTags: options.contextFreeTags,\n        enableEscapeTags: options.enableEscapeTags\n    });\n    // eslint-disable-next-line no-unused-vars\n    const tokens = tokenizer.tokenize();\n    return nodes.toArray();\n};\nexport { parse };\nexport default parse;\n","/* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object';\nconst isBool = (value)=>typeof value === 'boolean';\nexport function iterate(t, cb) {\n    const tree = t;\n    if (Array.isArray(tree)) {\n        for(let idx = 0; idx < tree.length; idx++){\n            tree[idx] = iterate(cb(tree[idx]), cb);\n        }\n    } else if (tree && isObj(tree) && tree.content) {\n        iterate(tree.content, cb);\n    }\n    return tree;\n}\nexport function same(expected, actual) {\n    if (typeof expected !== typeof actual) {\n        return false;\n    }\n    if (!isObj(expected) || expected === null) {\n        return expected === actual;\n    }\n    if (Array.isArray(expected)) {\n        return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));\n    }\n    return Object.keys(expected).every((key)=>{\n        const ao = actual[key];\n        const eo = expected[key];\n        if (isObj(eo) && eo !== null && ao !== null) {\n            return same(eo, ao);\n        }\n        if (isBool(eo)) {\n            return eo !== (ao === null);\n        }\n        return ao === eo;\n    });\n}\nexport function match(expression, cb) {\n    return Array.isArray(expression) ? iterate(this, (node)=>{\n        for(let idx = 0; idx < expression.length; idx++){\n            if (same(expression[idx], node)) {\n                return cb(node);\n            }\n        }\n        return node;\n    }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);\n}\n","import { parse } from '@bbob/parser';\nimport { iterate, match } from './utils';\nfunction walk(cb) {\n    return iterate(this, cb);\n}\nexport default function bbob(plugs) {\n    const plugins = typeof plugs === 'function' ? [\n        plugs\n    ] : plugs || [];\n    let options = {\n        skipParse: false\n    };\n    return {\n        process (input, opts) {\n            options = opts || {};\n            const parseFn = options.parser || parse;\n            const renderFn = options.render;\n            const data = options.data || null;\n            if (typeof parseFn !== 'function') {\n                throw new Error('\"parser\" is not a function, please pass to \"process(input, { parser })\" right function');\n            }\n            let tree = options.skipParse ? input || [] : parseFn(input, options);\n            // raw tree before modification with plugins\n            const raw = tree;\n            tree.messages = [];\n            tree.options = options;\n            tree.walk = walk;\n            tree.match = match;\n            plugins.forEach((plugin)=>{\n                tree = plugin(tree, {\n                    parse: parseFn,\n                    render: renderFn,\n                    iterate,\n                    match,\n                    data\n                }) || tree;\n            });\n            return {\n                get html () {\n                    if (typeof renderFn !== 'function') {\n                        throw new Error('\"render\" function not defined, please pass to \"process(input, { render })\"');\n                    }\n                    return renderFn(tree, tree.options);\n                },\n                tree,\n                raw,\n                messages: tree.messages\n            };\n        }\n    };\n}\n","import core from '@bbob/core';\nimport { attrsToString } from '@bbob/plugin-helper';\nconst SELFCLOSE_END_TAG = '/>';\nconst CLOSE_START_TAG = '</';\nconst START_TAG = '<';\nconst END_TAG = '>';\nconst renderNode = (node, { stripTags =false  })=>{\n    if (!node) return '';\n    const type = typeof node;\n    if (type === 'string' || type === 'number') {\n        return node;\n    }\n    if (type === 'object') {\n        if (stripTags === true) {\n            // eslint-disable-next-line no-use-before-define\n            return renderNodes(node.content, {\n                stripTags\n            });\n        }\n        if (node.content === null) {\n            return [\n                START_TAG,\n                node.tag,\n                attrsToString(node.attrs),\n                SELFCLOSE_END_TAG\n            ].join('');\n        }\n        // eslint-disable-next-line no-use-before-define\n        return [\n            START_TAG,\n            node.tag,\n            attrsToString(node.attrs),\n            END_TAG,\n            renderNodes(node.content),\n            CLOSE_START_TAG,\n            node.tag,\n            END_TAG\n        ].join('');\n    }\n    if (Array.isArray(node)) {\n        // eslint-disable-next-line no-use-before-define\n        return renderNodes(node, {\n            stripTags\n        });\n    }\n    return '';\n};\nconst renderNodes = (nodes, { stripTags =false  } = {})=>[].concat(nodes).reduce((r, node)=>r + renderNode(node, {\n            stripTags\n        }), '');\nconst toHTML = (source, plugins, options)=>core(plugins).process(source, {\n        ...options,\n        render: renderNodes\n    }).html;\nexport const render = renderNodes;\nexport default toHTML;\n","/**\n * Plugin that converts line breaks to `<br/>` tags.\n * To use, put as function similar to the presets.\n *\n * If a node is marked with `noLineBreakConversion`, then it'll skip the parsing the children\n *\n * @example\n * ```ts\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n */\nimport { isEOL } from \"@bbob/plugin-helper\";\n\n/**\n * Checks if input is an object\n * @param value input\n * @returns if value is an object\n */\nconst isObj = (value) => typeof value === \"object\";\n\n/**\n * Walks the tree of nodes. Will convert `\\n` to `br` tag in format that can be used in any renderer.\n * If a node has the property noLineBreakConversion is encountered, will skip parsing children.\n * @param t tree of nodes to be processed\n * @returns modified tree\n */\nconst walk = (t) => {\n  const tree = t;\n\n  if (Array.isArray(tree)) {\n    for (let idx = 0; idx < tree.length; idx++) {\n      const child = walk(tree[idx]);\n      if (Array.isArray(child)) {\n        tree.splice(idx, 1, ...child);\n        idx += child.length;\n      } else {\n        tree[idx] = child;\n      }\n    }\n  } else if (tree && isObj(tree) && tree.content) {\n    if (tree.disableLineBreakConversion) {\n      // stop walk. children won't be parsed to have <br>\n      return tree.tag ? tree : tree.content;\n    }\n    walk(tree.content);\n  }\n\n  if (isEOL(tree)) {\n    return { tag: \"br\", content: null };\n  }\n\n  return tree;\n};\n\n/**\n * Converts `\\n` to `<br/>` self closing tag. Supply this as the last plugin in the preset lists\n *\n * @example converts all line breaks to br\n * ```ts\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n * @example will not convert line breaks inside [nobr]\n * ```ts\n * const nobr = (node: TagNode) => {return { disableLineBreakConversion: true, content: node.content }}; \\\\ tag in preset\n * ...\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n * @returns plugin to be used in BBob process\n */\nexport const lineBreakPlugin = () => {\n  return (tree) => walk(tree);\n};\n","import { availableTags, preset } from \"./preset\";\nimport bbob from \"@bbob/core\";\nimport { render } from \"@bbob/html\";\nimport { lineBreakPlugin } from \"./plugins/lineBreak\";\n\nconst data = [];\n\n// const code = `[i][b]Text[/b][/i][font]test[/font][font=default attrtest]default[/font]`;\nconst options = {\n  onlyAllowTags: [...availableTags, \"nobr\"],\n  enableEscapeTags: true,\n  onError: (err) =>\n    // eslint-disable-next-line no-console\n    console.warn(err.message, err.lineNumber, err.columnNumber),\n  data,\n};\n\n// const bbobOutput = bbob(preset()).process(code, { render, ...options });\n\n// console.log(bbobOutput);\n\n// const html = bbobOutput.html;\n\n// console.log(data);\n\n// console.log(html); // <span style=\"font-style: italic;\">Text</span>\n\nexport const RpNBBCode = (code) =>\n  bbob([preset(), lineBreakPlugin()]).process(code, {\n    render,\n    ...options,\n  });\n// export default RpNBBCode;\n"],"names":["isTagNode","el","tag","process","tags","tree","core","options","walk","node","b","attr","style","content","font","console","log","nobr","disableLineBreakConversion","availableTags","Object","keys","preset","createPreset","defTags","processor","presetFactory","opts","assign","presetExecutor","extend","callback","N","TAB","EQ","QUOTEMARK","SPACE","OPEN_BRAKET","CLOSE_BRAKET","SLASH","BACKSLASH","keysReduce","obj","reduce","def","getNodeLength","count","contentNode","length","escapeHTML","value","replace","attrValue","name","type","types","boolean","number","string","object","JSON","stringify","attrsToString","values","arr","key","join","getTagAttrs","params","uniqAattr","attrs","res","tagAttr","TagNode","this","append","push","appendToNode","toTagStart","openTag","closeTag","toTagEnd","toTagNode","toLowerCase","toString","isEmpty","r","tagStart","constructor","Array","isArray","create","isOf","TOKEN_TYPE_ID","TOKEN_VALUE_ID","TOKEN_LINE_ID","getTokenValue","token","isTagEnd","charCodeAt","Token","isNaN","isText","isTag","isAttrName","isAttrValue","isStart","isEnd","getName","slice","getTagName","getValue","getLine","getColumn","text","convertTagToText","line","row","Number","String","CharGrabber","source","cursor","pos","len","hasNext","skip","num","silent","onSkip","curr","getCurr","getRest","substring","getNext","nextPos","getPrev","prevPos","isLast","includes","val","indexOf","grabWhile","cond","start","grabN","substrUntilChar","char","idx","createCharGrabber","NodeList","nodes","toArray","getLast","flushLast","pop","createList","createLexer","buffer","STATE_WORD","STATE_TAG","STATE_TAG_ATTRS","TAG_STATE_NAME","TAG_STATE_ATTR","TAG_STATE_VALUE","col","tokenIndex","stateMode","tagMode","contextFreeTag","tokens","Math","floor","escapeTags","enableEscapeTags","contextFreeTags","onToken","RESERVED_CHARS","NOT_CHAR_TOKENS","WHITESPACES","SPECIAL_CHARS","isCharReserved","isNewLine","isWhiteSpace","isCharToken","isSpecialChar","isEscapableChar","isEscapeChar","unq","str","charToRemove","charAt","trimChar","checkContextFreeMode","isClosingTag","chars","emitToken","cl","createToken","nextTagState","tagChars","isSingleValueTag","validAttrName","isValue","stateSpecial","validAttrValue","isQM","prevChar","nextChar","isPrevSLASH","isNextEQ","isWS","isNextWS","name1","name2","stateTag","currChar","substr","hasInvalidChars","isNoAttrsInTag","stateAttrs","tagStr","tagGrabber","hasSpace","stateWord","fullTagLen","fullTagName","isChar","tokenize","isTokenNested","parse","input","tokenizer","nestedNodes","tagNodes","tagNodesAttrName","nestedTagsMap","Set","flushTagNodes","appendNodes","items","lastNestedNode","getNodes","onlyAllowTags","forEach","item","handleTagStart","tagNode","isNested","has","add","handleTag","onError","column","message","tagName","lineNumber","columnNumber","handleTagEnd","handleNode","lastTagNode","tokenValue","Boolean","attrName","createTokenizer","isObj","isBool","iterate","t","cb","same","expected","actual","every","exp","some","call","act","ao","eo","match","expression","SELFCLOSE_END_TAG","CLOSE_START_TAG","START_TAG","END_TAG","renderNodes","stripTags","concat","renderNode","render","child","splice","err","warn","data","RpNBBCode","code","plugs","plugins","skipParse","parseFn","parser","renderFn","Error","raw","messages","plugin","html","bbob"],"mappings":"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","x_google_ignoreList":[0,5,6,7,8,9,10,11,12,13,14]}